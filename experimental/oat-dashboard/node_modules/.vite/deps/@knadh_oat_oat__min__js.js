var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// node_modules/@knadh/oat/oat.min.js
var _t, _OtBase_instances, e_fn;
var OtBase = class extends HTMLElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _OtBase_instances);
    __privateAdd(this, _t, false);
  }
  connectedCallback() {
    __privateGet(this, _t) || (document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", () => __privateMethod(this, _OtBase_instances, e_fn).call(this), { once: true }) : __privateMethod(this, _OtBase_instances, e_fn).call(this));
  }
  init() {
  }
  disconnectedCallback() {
    this.cleanup();
  }
  cleanup() {
  }
  handleEvent(t) {
    const n = this[`on${t.type}`];
    n && n.call(this, t);
  }
  emit(t, n = null) {
    return this.dispatchEvent(new CustomEvent(t, { bubbles: true, composed: true, cancelable: true, detail: n }));
  }
  getBool(t) {
    return this.hasAttribute(t);
  }
  setBool(t, n) {
    n ? this.setAttribute(t, "") : this.removeAttribute(t);
  }
  $(t) {
    return this.querySelector(t);
  }
  $$(t) {
    return Array.from(this.querySelectorAll(t));
  }
  uid() {
    return Math.random().toString(36).slice(2, 10);
  }
};
_t = new WeakMap();
_OtBase_instances = new WeakSet();
e_fn = function() {
  __privateGet(this, _t) || (__privateSet(this, _t, true), this.init());
};
typeof window < "u" && (window.OtBase = OtBase), "commandForElement" in HTMLButtonElement.prototype || document.addEventListener("click", (e) => {
  const t = e.target.closest("[commandfor]");
  if (!t) return;
  const n = document.getElementById(t.getAttribute("commandfor"));
  if (!n) return;
  const i = t.getAttribute("command") || "toggle";
  n instanceof HTMLDialogElement && (i === "show-modal" ? n.showModal() : i === "close" || n.open ? n.close() : n.showModal());
});
var _t2, _e, _OtTabs_instances, n_fn;
var OtTabs = class extends OtBase {
  constructor() {
    super(...arguments);
    __privateAdd(this, _OtTabs_instances);
    __privateAdd(this, _t2, []);
    __privateAdd(this, _e, []);
  }
  init() {
    const t = this.$(':scope > [role="tablist"]');
    if (__privateSet(this, _t2, t ? [...t.querySelectorAll('[role="tab"]')] : []), __privateSet(this, _e, this.$$(':scope > [role="tabpanel"]')), __privateGet(this, _t2).length === 0 || __privateGet(this, _e).length === 0) {
      console.warn("ot-tabs: Missing tab or tabpanel elements");
      return;
    }
    __privateGet(this, _t2).forEach((i, o) => {
      const s = __privateGet(this, _e)[o];
      if (!s) return;
      const a = i.id || `ot-tab-${this.uid()}`, r = s.id || `ot-panel-${this.uid()}`;
      i.id = a, s.id = r, i.setAttribute("aria-controls", r), s.setAttribute("aria-labelledby", a), i.addEventListener("click", this), i.addEventListener("keydown", this);
    });
    const n = __privateGet(this, _t2).findIndex((i) => i.ariaSelected === "true");
    __privateMethod(this, _OtTabs_instances, n_fn).call(this, n >= 0 ? n : 0);
  }
  onclick(t) {
    const n = __privateGet(this, _t2).indexOf(t.target.closest('[role="tab"]'));
    n >= 0 && __privateMethod(this, _OtTabs_instances, n_fn).call(this, n);
  }
  onkeydown(t) {
    const { key: n } = t, i = this.activeIndex;
    let o = i;
    switch (n) {
      case "ArrowLeft":
        t.preventDefault(), o = i - 1, o < 0 && (o = __privateGet(this, _t2).length - 1);
        break;
      case "ArrowRight":
        t.preventDefault(), o = (i + 1) % __privateGet(this, _t2).length;
        break;
      default:
        return;
    }
    __privateMethod(this, _OtTabs_instances, n_fn).call(this, o), __privateGet(this, _t2)[o].focus();
  }
  get activeIndex() {
    return __privateGet(this, _t2).findIndex((t) => t.ariaSelected === "true");
  }
  set activeIndex(t) {
    t >= 0 && t < __privateGet(this, _t2).length && __privateMethod(this, _OtTabs_instances, n_fn).call(this, t);
  }
};
_t2 = new WeakMap();
_e = new WeakMap();
_OtTabs_instances = new WeakSet();
n_fn = function(t) {
  __privateGet(this, _t2).forEach((n, i) => {
    const o = i === t;
    n.ariaSelected = String(o), n.tabIndex = o ? 0 : -1;
  }), __privateGet(this, _e).forEach((n, i) => {
    n.hidden = i !== t;
  }), this.emit("ot-tab-change", { index: t, tab: __privateGet(this, _t2)[t] });
};
customElements.define("ot-tabs", OtTabs);
var _t3, _e2, _n;
var OtDropdown = class extends OtBase {
  constructor() {
    super(...arguments);
    __privateAdd(this, _t3);
    __privateAdd(this, _e2);
    __privateAdd(this, _n);
  }
  init() {
    __privateSet(this, _t3, this.$("menu[popover]")), __privateSet(this, _e2, this.$("[popovertarget]")), !(!__privateGet(this, _t3) || !__privateGet(this, _e2)) && (__privateGet(this, _t3).addEventListener("toggle", this), __privateGet(this, _t3).addEventListener("keydown", this), __privateSet(this, _n, () => {
      const t = __privateGet(this, _e2).getBoundingClientRect();
      __privateGet(this, _t3).style.top = `${t.bottom}px`, __privateGet(this, _t3).style.left = `${t.left}px`;
    }));
  }
  ontoggle(t) {
    var _a;
    t.newState === "open" ? (__privateGet(this, _n).call(this), window.addEventListener("scroll", __privateGet(this, _n), true), (_a = this.$('[role="menuitem"]')) == null ? void 0 : _a.focus(), __privateGet(this, _e2).ariaExpanded = "true") : (window.removeEventListener("scroll", __privateGet(this, _n), true), __privateGet(this, _e2).ariaExpanded = "false", __privateGet(this, _e2).focus());
  }
  onkeydown(t) {
    var _a, _b;
    if (!t.target.matches('[role="menuitem"]')) return;
    const n = this.$$('[role="menuitem"]'), i = n.indexOf(t.target);
    switch (t.key) {
      case "ArrowDown":
        t.preventDefault(), (_a = n[(i + 1) % n.length]) == null ? void 0 : _a.focus();
        break;
      case "ArrowUp":
        t.preventDefault(), (_b = n[i - 1 < 0 ? n.length - 1 : i - 1]) == null ? void 0 : _b.focus();
        break;
    }
  }
  cleanup() {
    window.removeEventListener("scroll", __privateGet(this, _n), true);
  }
};
_t3 = new WeakMap();
_e2 = new WeakMap();
_n = new WeakMap();
customElements.define("ot-dropdown", OtDropdown);
var ot = window.ot || (window.ot = {});
var containers = {};
var DEFAULT_DURATION = 4e3;
var DEFAULT_PLACEMENT = "top-right";
function getContainer(e) {
  if (!containers[e]) {
    const t = document.createElement("div");
    t.className = "toast-container", t.setAttribute("popover", "manual"), t.setAttribute("data-placement", e), document.body.appendChild(t), containers[e] = t;
  }
  return containers[e];
}
function show(e, t = {}) {
  const { placement: n = DEFAULT_PLACEMENT, duration: i = DEFAULT_DURATION } = t, o = getContainer(n);
  e.classList.add("toast");
  let s;
  return e.onmouseenter = () => clearTimeout(s), e.onmouseleave = () => {
    i > 0 && (s = setTimeout(() => removeToast(e, o), i));
  }, e.setAttribute("data-entering", ""), o.appendChild(e), o.showPopover(), requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      e.removeAttribute("data-entering");
    });
  }), i > 0 && (s = setTimeout(() => removeToast(e, o), i)), e;
}
ot.toast = function(e, t, n = {}) {
  typeof e == "object" && e !== null && (n = e, e = "");
  const { variant: i = "", ...o } = n, s = document.createElement("output");
  s.className = "toast", s.setAttribute("role", "status"), i && s.setAttribute("data-variant", i);
  const a = t || i[0].toUpperCase() + i.slice(1), r = document.createElement("h6");
  if (r.className = "toast-title", i && (r.style.color = `var(--${i})`), r.textContent = t || a, s.appendChild(r), e) {
    const l = document.createElement("div");
    l.className = "toast-message", l.textContent = e, s.appendChild(l);
  }
  return show(s, o);
}, ot.toastEl = function(e, t = {}) {
  let n;
  return e instanceof HTMLTemplateElement ? n = e.content.firstElementChild.cloneNode(true) : typeof e == "string" ? n = document.querySelector(e).cloneNode(true) : n = e.cloneNode(true), n.removeAttribute("id"), show(n, t);
};
function removeToast(e, t) {
  if (e.hasAttribute("data-exiting")) return;
  e.setAttribute("data-exiting", "");
  let n = false;
  const i = () => {
    n || (n = true, e.remove(), t.children.length || t.hidePopover());
  };
  e.addEventListener("transitionend", i, { once: true }), setTimeout(i, 200);
}
ot.toast.clear = function(e) {
  e && containers[e] ? (containers[e].innerHTML = "", containers[e].hidePopover()) : Object.values(containers).forEach((t) => {
    t.innerHTML = "", t.hidePopover();
  });
}, document.addEventListener("DOMContentLoaded", () => {
  document.querySelectorAll("[title]").forEach((e) => {
    const t = e.getAttribute("title");
    t && (e.setAttribute("data-tooltip", t), e.hasAttribute("aria-label") || e.setAttribute("aria-label", t), e.removeAttribute("title"));
  });
}), document.addEventListener("click", (e) => {
  var _a;
  const t = e.target.closest("[data-sidebar-toggle]");
  t && ((_a = t.closest("[data-sidebar-layout]")) == null ? void 0 : _a.toggleAttribute("data-sidebar-open"));
});
//# sourceMappingURL=@knadh_oat_oat__min__js.js.map
